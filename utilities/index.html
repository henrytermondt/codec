<!DOCTYPE html>
<html>
    <head>
        <title></title>
        <link rel='icon' type='image/x-icon' href='/favicon.ico'>

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Poppins&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="/main-styles.css">
        
        <style>
            body {
                /* margin: 0; */
                height: 100%;
                background-color: var(--primary);

                font-family: 'Poppins', 'Trebuchet MS', Verdana, Tahoma, Roboto, sans-serif;
            }
            *:not(#canvas, #filter) {
                background-color: black;

            }

            m-el {
                pointer-events: none;
            }

            #contents {
                width: 100%;
                height: 94vh;
                margin-top: 0;
                background-color: var(--light);
            }
            #canvas {
                position: relative;
                left: calc(50vw - 400px);
                top: calc(50vh - 300px);
                /* top: 10px;
                left: 10px;
                margin-right: 15px;
                margin-bottom: 10px; */
            }
        </style>
        <style></style>

        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/tex-mml-chtml.js"></script>
    </head>
    <body>
        <!-- <m-el>\(\)</m-el> -->
        <canvas id='canvas'></canvas>
        <!-- <canvas id='logo' style='border-radius: 3px;'></canvas> -->
        <!-- <textarea id='contents'></textarea> -->
        <div id='filter'></div>
        <script>

// Defines a custom element. It makes code easier to read as well as write by shortening the name of elements that hold math
class MathElement extends HTMLElement {
    constructor() { // Has no special functionality as it is simply to wrap math and provide a selector for the CSS
        super();
    }
}
customElements.define('m-el', MathElement);

        </script>

        <script>

let projects;
const addProject = (name, data) => {
    projects[name] = data;
    console.log(JSON.stringify(projects));
};
const setProjectContent = (name, contents) => {
    projects[name].html = contents;
    console.log(JSON.stringify(projects));
    console.log(projects);
};
const setProjectProperty = (name, prop, val) => {
    projects[name][prop] = val;
    console.log(JSON.stringify(projects));
    console.log(projects);
};


const onProjectLoad = () => {
    // setProjectContent('', String.raw``);
};

fetch('/projects/projects.json').then(data => {
    data.json().then(response => {
        projects = response;
        console.log(response);

        onProjectLoad();
    });
});

const getContent = () => {
    console.log(content.innerHTML);
};
const contents = document.getElementById('contents');
let curProject = null;
const getPage = project => {
    curProject = project;
    contents.textContent = projects[project].html;
};
const changeJSON = () => setProjectContent(curProject, String.raw`${contents.textContent}`);

// Recent {
// {"raytracing":{"name":"Raytracing","img":"./projects/raytracing/thumbnail.png","desc":"Render realistic 3D scenes by simulating light rays"},"penrose-tilings":{"name":"Penrose Tilings","img":"./projects/penrose-tilings/penrose-background.png","desc":"Create the geometric tilings found on this webpage"},"newtons-fractal":{"name":"Newton's Fractal","img":"./projects/newtons-fractal/thumbnail.png","desc":"Use Newton's method to create an iconic fractal"},"life":{"name":"Conway's Game of Life","img":"./projects/conways-game-of-life/thumbnail.png","desc":"Create cellular automata that mimic life","html":"\n                    <h2>What is Conway's Game of Life?</h2>\n                    <div>\n                        <img class = 'img' src = './projects/conways-game-of-life/thumbnail.png'>\n                        <p>\n                            Conway's Game of Life is something called a <i>cellular automata</i>\n                            which tries to mimic how life works through a simple set of rules.\n                            A cellular automata is made up of a grid of tiles, called cells, each\n                            with a state. In this case, the only possible states are either alive\n                            or dead. A cell will change its state from alive to dead and vice versa\n                            based on the number of living cells surrounding it.\n                            Different cellular automata (like Day and Night, which is another project\n                            you can try out) are defined by how different numbers of living cells\n                            change a cell's state as well as how many states exist. In this case,\n                            if there is a cell with 2-3 living neighbors, then the cell survives\n                            on to the next generation, but any living cell with more than 3 living neighbors\n                            will die and change state. This mimics overpopulation. Likewise, any\n                            cell with <i>fewer</i> than 2 living neighbors will die which represents\n                            underpopulation. There is just one last rule. If a dead cell has\n                            precisely 3 living neighbors, it will become a living cell again. This\n                            mimics reproduction, completing the cycle of life.\n                        </p>\n                    </div>\n                    <br>\n                    <h2>Interesting Patterns</h2>\n                    <div>\n                        <p>\n                            <img class = 'img' style = 'position: relative; image-rendering: pixelated;' src = './projects/conways-game-of-life/glider.png'>\n                            One of the joys of this project is setting the initial states of the cells\n                            to be a certain pattern and watching it evolve. You might find that some of\n                            the starting patterns will have special properties. Some of the more common\n                            special properties (ignore the oxymoron; they're important to notice but\n                            often irrelevant (haha)) are sorted into three groups: still lifes, oscillators,\n                            and spaceships. Still lifes are unchanging, while oscillators repeat some number\n                            of patterns indefinitely. Spaceships are like oscillators, because they always\n                            return to a certain pattern, but they also move across the grid of cells. On\n                            the right is arguably the simplest spaceship. There are still very many more\n                            interesting starting patterns, which you can find in the website listed in the\n                            <a href = '#further-reading'>further reading</a> section.\n                        </p>\n                    </div>\n                    <br>\n                    <h2>Common Pitfalls</h2>\n                    <p>\n                        The most common area where people go wrong is to update the grid of cells\n                        as you're looking at it. Essentially, you have a copy of the original grid\n                        which you reference in order to know the number of living neighbors around\n                        a cell and you update the original while looking at the copy. This prevents\n                        you from trying to reference parts of the grid which are already part of the\n                        next generation. The incorrect version is called Naive Life.\n                    </p>\n                    <br>\n                    <h2>Background</h2>\n                    <p>\n                        Conway's Game of Life is often shortened to The Game of Life, or just Life.\n                        As you might have guessed, it was invented by John Conway. He called\n                        it a 0 player game since all you have to do is input a pattern and the\n                        game will play itself until it reaches a predictable state. An interesting\n                        concept that has a connection to Conway's Game of Life is the idea of\n                        Turing Completeness. If a system is Turing complete, it is able to solve\n                        any logical problem that can be solved (it might surprise you that some\n                        problems in math and programming literally <i>cannot</i> be solved). Conway's\n                        Game of Life just so happens to be Turing complete, just like a lot of\n                        programming languages and even popular video games. What that means is\n                        that the Game of Life can technically solve anything that you can. This\n                        can be taken to the extreme, and people have even coded the\n                        <a href = 'https://www.youtube.com/watch?v=xP5-iIeKXE8' target = '_blank'>Game of Life inside of itself</a>!\n                    </p>\n                    <br>\n                    <h2 id = 'further-reading'>Further Reading</h2>\n                    <ul id = 'further-reading-list'>\n                        <li><a href = 'https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life'>Wikipedia: Conway's Game of Life</a></li>\n                    </ul>\n                "}}
//}
/*
{"raytracing":{"name":"Raytracing","img":"./projects/raytracing/thumbnail.png","desc":"Render realistic 3D scenes by simulating light rays"},"penrose-tilings":{"name":"Penrose Tilings","img":"./projects/penrose-tilings/penrose-background.png","desc":"Create the geometric tilings found on this webpage","html":"<h2>What are Penrose Tilings?</h2>\n                    <p>\n                        Let's say you have an infinite amount of tiles of a certain\n                        shape, like a square. You can slide them together in a grid on a plane (an infinte flat surface)\n                        and that grid will go on without stopping. The same goes for\n                        triangles and hexagons. These grids are repeating which means\n                        that if you have two copies of the grid, one on top of the\n                        other, you can slide one around and it will line up perfectly\n                        with the other. This is called a <i>periodic</i> tiling.\n                        Other shapes don't have this special infinite\n                        tiling property, like pentagons. However, if you allow more\n                        shapes, than just the pentagon, you can tile the grid. A\n                        question you might ask is, is it possible to create a finite\n                        number of tiles that tile the plane, but <i>don't</i> tile it\n                        periodically? In other words, is it possible to create an\n                        infinite tiling that never repeats? The answer is actually yes!\n                        The first set of tiles that people found had over 1,000 different\n                        tiles in it and were called Wang Tiles. Other researchers\n                        started trying to reduce the number of types of tiles and\n                        slowly worked it down to a few hundred, and then down to six.\n                        Now the protagonist of this story enters! Robert Penrose managed\n                        to reduce the number of types of tiles to just two shapes: a\n                        thick and a thin rhombus (affectionately called by mathematicians\n                        \"rhombs\"). With those two tiles, you can create a pattern that\n                        never repeats and yet goes on forever. This type of pattern is\n                        called a penrose tiling and are what we'll be exploring here.\n                        They've also been used in Islamic tilings.\n                    </p>\n                    <p>\n                        There are variants of penrose tilings that use more than just\n                        two types of tiles, such as the one depicted below. They are\n                        still aperiodic and often look better, but it is worth noting\n                        that not all images that are on this webpage are \"true\" penrose\n                        tiles.\n                    </p>\n                    <div class='img-container'>\n                        <img class='big-img' alt='An example of a penrose tiling variant used extensively across this website' src='./projects/penrose-tilings/penrose-background.png' style='max-width: 500px; width: 60%;'>\n                        <span class='caption'>Penrose tilings are used all across this website.</span>\n                    </div>\n                    <h2>How are They Created?</h2>\n                    <p>\n                        This article will be different from most of the others, because\n                        it'll go much more in-depth. There are very few resources on the\n                        internet which are detailed enough to figure out how to create\n                        penrose tilings and most of them are academic papers. I'm\n                        attempting to give a full, yet understandable explanation of\n                        how to create them in a program, rather than in real life.\n                    </p>\n                    <p>\n                        To start off, a key concept is that there is an alternate representation of a\n                        tiling. For a regular penrose tiling (i.e. only two tiles), that\n                        representation is something called a pentagrid. A pentagrid is\n                        where you have a 5 sets of parallel lines which are offset from\n                        each other by 72°, as seen in the picture below.\n                    </p>\n                    <div class='img-container'>\n                        <img class='big-img' alt='A pentagrid' src='./projects/penrose-tilings/pentagrid-better-colors.png' style='max-width: 180px; width: 40%;'>\n                    </div>\n                    <p>\n                        It contains the\n                        exact same information as the actual tiling, but just in another\n                        form (you can think of it like how 9 in base ten is the same as\n                        1001 in binary). Each intersection represents a single tile in the completed Penrose tiling. The\n                        number and angles of the lines that intersect encode properties of\n                        the tile. The shape that the intersection represents has 2 times\n                        the number of lines that intersect. The angles of the lines dictate\n                        how the overall rotation of the shape as well as the angles of the\n                        edges. The method of creating a pentagrids is\n                        rather peculiar. Essentially, you need to use an equation for a\n                        line that is rarely ever used. It draws the line tangent to a circle\n                        with a radius <m-el>\\(r\\)</m-el> at the point\n                        <m-el>\\(\\theta\\)</m-el> radians around the circle.\n                        The following is the formula for that equation of a line.\n                    </p>\n                    <m-el>\\[x\\sin\\left(\\theta+\\frac{\\pi}{2}\\right)=y\\cos\\left(\\theta+\\frac{\\pi}{2}\\right)+r\\]</m-el>\n                    <p>\n                        Using this formula, you can create 5 lines with <m-el>\\(r = 1\\)</m-el>,\n                        each rotated by an integer multiple of 72° (in radians, they would\n                        be rotated multiples of <m-el>\\(\\frac{2\\pi}{5}\\)</m-el>).\n                        Then, repeat this for as many increasing integers of <m-el>\\(r\\)</m-el>\n                        as you would like. In other words, <m-el>\\(r=1,2,3,4...\\)</m-el> etc.\n                        The more times you repeat this, the larger the eventual tiling will be.\n                        This equation has one small issue, though. Right now, if you follow this\n                        process exactly, the resulting pentagrid will have 5 lines intersecting\n                        at the center. If we want to create a \"true\" penrose tiling, this will\n                        create a third type of tile, which we don't want. In order to fix that,\n                        we can simply add an offset from 0 to 1 to the lefthand side of the\n                        equation, like so (notice the <m-el>\\(o\\)</m-el>):\n                    </p>\n                    <m-el>\\[x\\sin\\left(\\theta+\\frac{\\pi}{2}\\right)+o=y\\cos\\left(\\theta+\\frac{\\pi}{2}\\right)+r\\]</m-el>\n                    <p>\n                        Now that we have a pentagrid, the next step is to translate the pentagrid\n                        into a penrose tiling. If you remember, each intersection translates to a\n                        tile and the properties of the lines translate to the properties of the\n                        tile, like number of sides and rotation. The nice this is, we don't have to\n                        worry that much about the specifics, because the pentagrid also carries the\n                        information on exactly how the vertices should be placed. That information\n                        is held within the blank areas around the lines, as each blank area actually\n                        represents a vertex of a shape (if you think about it, this leads to why\n                        the tiles are guaranteed to fit so nicely together. Since multiple intersections\n                        are bordering the same blank space, they all will share the same vertex).\n                        Zooming in on a single intersection, each of the colored regions translates to a vertex of\n                        the intersection's shape:\n                    </p>\n                    <div class='img-container'>\n                        <img class='big-img' alt='A pentagrid' src='./projects/penrose-tilings/pentagrid-region-diagram.png' style='max-width: 180px; width: 40%;'>\n                    </div>\n                    <p>\n                        As you can see, four regions border the intersection in the center, meaning that the\n                        resulting shape will have four vertices, and therefore, will be a quadrilateral.\n                        Up until now, we've been fairly abstract about how the whole translation\n                        process will work. The secret is a special formula developed by de Bruijn:\n                    </p>\n                    <m-el>\\[V\\left(\\overrightarrow{x}\\right)=\\sum_{j=0}^{4}K_{j}\\left(\\overrightarrow{x}\\right)\\overrightarrow{v_{j}}\\]</m-el>\n                    <p>\n                        Since there's a lot going on, let's break it down. The function <m-el>\\(V\\)</m-el>\n                        takes in a position, <m-el>\\(\\overrightarrow{x}\\)</m-el>, and\n                        outputs a vertex of a shape in the eventual tiling. <m-el>\\(V(\\overrightarrow{x})\\)</m-el>\n                        will always output the same point for inputs inside of the same region of the pentagrid.\n                        <m-el>\\(\\overrightarrow{x}\\)</m-el> and <m-el>\\(\\overrightarrow{v}\\)</m-el>\n                        are represented as vectors. Sums are inclusive, meaning that, in this case,\n                        <m-el>\\(j\\)</m-el> has 5 values: 0, 1, 2, 3, and 4. \n                        <m-el>\\(\\overrightarrow{v_{j}}\\)</m-el> is a unit vector with\n                        an angle of <m-el>\\(\\frac{2\\pi j}{5}\\)</m-el> radians.\n                        <m-el>\\(K_{j}\\left(\\overrightarrow{x}\\right)\\)</m-el> is defined as\n                        the following:\n                    </p>\n                    <m-el>\\[K_{j}\\left(\\overrightarrow{x}\\right)=\\operatorname{ceil}\\left(\\overrightarrow{x}\\cdot \\overrightarrow{v}+o\\right)\\]</m-el>\n                    <p>\n                        <m-el>\\(\\operatorname{ceil}\\)</m-el> is a function which rounds up\n                        whatever its input is and <m-el>\\(o\\)</m-el> is the offset for the pentagrid.\n                        Now that we have the formula defined, we can talk about how to use it. At each\n                        intersection, simply find a point in each neighboring reigon and run that point\n                        through the formula. Take the new vertices outputted by the formula and set them\n                        to be the vertices of a tile. Repeat this process for as many intersections as you\n                        would like to create differently sized tilings. An issue still remains. There might\n                        be tiles floating off in space, disconnected from the main bulk of tiles. To get rid\n                        of them, you can only create tiles that are a less than a certain distance from the\n                        center. Now, you can draw the tiles and bask in the glory of your newly formed\n                        penrose tiling!\n                    </p>\n                    <p>\n                        <strong>But wait! There's <i>more!</i></strong> What you have now is a \"true\"\n                        penrose tiling, but we're interested in exploring the falsehoods of this reality.\n                        So, how can the aforementioned variants of penrose tilings be created? It's actually\n                        pretty simple. All penrose tilings and their variants are rotationally symmetric,\n                        meaning that you can rotate it about its center and it'll line up with itself. To\n                        create variants, you need to increate the number of symmetries it has. This can simply\n                        be done by adding more lines to the pentagrid. Just make sure that the rotations of\n                        the lines from each other are changed from <m-el>\\(\\frac{2\\pi}{5}\\)</m-el> to\n                        <m-el>\\(\\frac{2\\pi}{s}\\)</m-el>, where <m-el>\\(s\\)</m-el> is the number of symmetries.\n                        De Bruijn's formula still works when there are more symmetries, but you're code probably\n                        doesn't, so remember to go through and change parts that are depended on symmetries, like\n                        the number and direction of the unit vectors as well as the upper bound of the sum in\n                        de Bruijn's formula. Another thing that might need adjusting is how you handle the\n                        intersection of multiple lines. Make sure it's compatible with more than two lines\n                        at an intersection (for the vocabulary nerds like me, this is called a \"point of\n                        concurrency\"). An added benefit is that the offset can now be set to 0 without issue\n                        which often looks cool.\n                    </p>\n                    <br>\n                    <h2>Helpful Tips</h2>\n                    <ul>\n                        <li>\n                            If your tiles' vertices seem to be in the right place, but in a wacky order,\n                            try sorting the lines by their angle first.\n                        </li>\n                        <li>\n                            If you want to be able to store and differentiate different types of tiles\n                            for coloring and other effects, you can find their area. Each type of tile\n                            should have its own area. Remember to round it to a couple decimal places,\n                            so floating point errors won't get in the way.\n                        </li>\n                        <li>\n                            The sizes of the regions in pentagrids get what mathematicians say is \"arbitrarily\n                            small\". In other words, they get tiny. Really tiny. Make sure that if you find points\n                            in regions next to intersections by taking a step in the direction of the region from\n                            the intersection, make sure that step is small enough; otherwise, you can go too far\n                            and enter another region, which you don't want.\n                        </li>\n                        <li>\n                            Often, lag will be caused by duplicated lines or tiles, so checking for those and\n                            removing them can help. \n                        </li>\n                    </ul>\n                    <br>\n                    <h2>Further Reading</h2>\n                    <ul>\n                        <li>\n                            <a href='https://www.youtube.com/watch?v=-eqdj63nEr4'>Why Penrose Tiles Never Repeat</a> - minutephysics.\n                            It's gives an excellent overview of the tilings as well as some intuitions about why the tilings act\n                            how they do. It isn't too rigorous, though.\n                        </li>\n                        <li>\n                            <a href='https://www.youtube.com/watch?v=48sCx-wBs34'>The Infinite Pattern That Never Repeats</a> - Veritasium.\n                            Provides an overview of how the tilings work and give a lot of interesting facts about them.\n                        </li>\n                        <li>\n                            <a href='http://www.neverendingbooks.org/tag/penrose-tiling'>de Bruijn's pentagrids</a> - LIEVENLB\n                            An article which goes over how the formulas for translating the pentagrid works as well\n                            as other facts and relations between other mathematical ideas.\n                        </li>\n                        <li>\n                            <a href='https://web.williams.edu/Mathematics/sjmiller/public_html/hudson/HRUMC-Mowry&Shukla_Pentagrids%20and%20Penrose.pdf'>Pentagrids and Penrose Tilings</a> - Stacy Mowry and Shriya Shukla\n                            Details a different slightly way of using de Bruijn's formula.\n                        </li>\n                        <li>\n                            <a href='https://www.math.brown.edu/reschwar/M272/pentagrid.pdf'>Algebraic theory of Penrose's non-periodic tilings of the plane</a> - N.G. de Bruijn\n                            De Bruijn's paper! It's very thorough and is the basis of almost all of the current methods.\n                            It's unfortunately not the most understandable to the average reader.\n                        </li>\n                    </ul>"},"newtons-fractal":{"name":"Newton's Fractal","img":"./projects/newtons-fractal/thumbnail.png","desc":"Use Newton's method to create an iconic fractal"},"life":{"name":"Conway's Game of Life","img":"./projects/conways-game-of-life/thumbnail.png","desc":"Create cellular automata that mimic life","html":"\n                    <h2>What is Conway's Game of Life?</h2>\n                    <div>\n                        <img class = 'img' src = './projects/conways-game-of-life/thumbnail.png'>\n                        <p>\n                            Conway's Game of Life is something called a <i>cellular automata</i>\n                            which tries to mimic how life works through a simple set of rules.\n                            A cellular automata is made up of a grid of tiles, called cells, each\n                            with a state. In this case, the only possible states are either alive\n                            or dead. A cell will change its state from alive to dead and vice versa\n                            based on the number of living cells surrounding it.\n                            Different cellular automata (like Day and Night, which is another project\n                            you can try out) are defined by how different numbers of living cells\n                            change a cell's state as well as how many states exist. In this case,\n                            if there is a cell with 2-3 living neighbors, then the cell survives\n                            on to the next generation, but any living cell with more than 3 living neighbors\n                            will die and change state. This mimics overpopulation. Likewise, any\n                            cell with <i>fewer</i> than 2 living neighbors will die which represents\n                            underpopulation. There is just one last rule. If a dead cell has\n                            precisely 3 living neighbors, it will become a living cell again. This\n                            mimics reproduction, completing the cycle of life.\n                        </p>\n                    </div>\n                    <br>\n                    <h2>Interesting Patterns</h2>\n                    <div>\n                        <p>\n                            <img class = 'img' style = 'position: relative; image-rendering: pixelated;' src = './projects/conways-game-of-life/glider.png'>\n                            One of the joys of this project is setting the initial states of the cells\n                            to be a certain pattern and watching it evolve. You might find that some of\n                            the starting patterns will have special properties. Some of the more common\n                            special properties (ignore the oxymoron; they're important to notice but\n                            often irrelevant (haha)) are sorted into three groups: still lifes, oscillators,\n                            and spaceships. Still lifes are unchanging, while oscillators repeat some number\n                            of patterns indefinitely. Spaceships are like oscillators, because they always\n                            return to a certain pattern, but they also move across the grid of cells. On\n                            the right is arguably the simplest spaceship. There are still very many more\n                            interesting starting patterns, which you can find in the website listed in the\n                            <a href = '#further-reading'>further reading</a> section.\n                        </p>\n                    </div>\n                    <br>\n                    <h2>Common Pitfalls</h2>\n                    <p>\n                        The most common area where people go wrong is to update the grid of cells\n                        as you're looking at it. Essentially, you have a copy of the original grid\n                        which you reference in order to know the number of living neighbors around\n                        a cell and you update the original while looking at the copy. This prevents\n                        you from trying to reference parts of the grid which are already part of the\n                        next generation. The incorrect version is called Naive Life.\n                    </p>\n                    <br>\n                    <h2>Background</h2>\n                    <p>\n                        Conway's Game of Life is often shortened to The Game of Life, or just Life.\n                        As you might have guessed, it was invented by John Conway. He called\n                        it a 0 player game since all you have to do is input a pattern and the\n                        game will play itself until it reaches a predictable state. An interesting\n                        concept that has a connection to Conway's Game of Life is the idea of\n                        Turing Completeness. If a system is Turing complete, it is able to solve\n                        any logical problem that can be solved (it might surprise you that some\n                        problems in math and programming literally <i>cannot</i> be solved). Conway's\n                        Game of Life just so happens to be Turing complete, just like a lot of\n                        programming languages and even popular video games. What that means is\n                        that the Game of Life can technically solve anything that you can. This\n                        can be taken to the extreme, and people have even coded the\n                        <a href = 'https://www.youtube.com/watch?v=xP5-iIeKXE8' target = '_blank'>Game of Life inside of itself</a>!\n                    </p>\n                    <br>\n                    <h2 id = 'further-reading'>Further Reading</h2>\n                    <ul id = 'further-reading-list'>\n                        <li><a href = 'https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life'>Wikipedia: Conway's Game of Life</a></li>\n                    </ul>\n                "}}
*/
        </script>

        <script>

const noise = (function() {
    const ranVectors = [];
    
    for (let i = 256; i --;) {
        const subArr = [];
        for (let j = 256; j --;) subArr.push(Math.random() * 10 | 0);
        ranVectors.push(subArr);
    }

    const constantVec = v => {
        switch(v & 3) {
            case 0:
                return [1, 1];
            break;
            case 1:
                return [-1, 1];
            break;
            case 2:
                return [-1, -1];
            break;
            case 3:
                return [1, -1];
        }
    }

    const dot = (a, b) => a[0] * b[0] + a[1] * b[1],
        lerp = (a, b, t) => a + (b - a) * t,
        fade = t => ((6 * t - 15) * t + 10) * t * t * t;
    
    const func = (x, y) => {
        x *= 10.0, y *= 10.0;
        const srx = (x / noise.detail | 0) & 255,
            sry = (y / noise.detail | 0) & 255,
            xf = (x - (x / noise.detail | 0) * noise.detail) / noise.detail,
            yf = (y - (y / noise.detail | 0) * noise.detail) / noise.detail,
            v = fade(yf);
    	return lerp(
            lerp(
                dot(
                    [xf, yf],
                    constantVec(ranVectors[sry][srx])
                ),
                dot(
                    [xf, yf - 1],
                    constantVec(ranVectors[sry + 1][srx])
                ),
                v
            ),
            lerp(
                dot(
                    [xf - 1, yf],
                    constantVec(ranVectors[sry][srx + 1])
                ),
                dot(
                    [xf - 1, yf - 1],
                    constantVec(ranVectors[sry + 1][srx + 1])
                ),
                v
            ),
            fade(xf)
        );
    }
    func.detail = 10;
    
    return func;
})(); 


const ctx = canvas.getContext('2d');
canvas.width = 800;
canvas.height = 600;

ctx.fillStyle = '#FEF8F7';
ctx.fillRect(0, 0, 800, 600);

const scale = 1.1;

const img = new Image();
img.src = '/projects/penrose-tilings/background-large.png';

img.onload = () => {
    // ctx.filter = 'blur(10px)';
    ctx.drawImage(img, -img.width / 2 * scale + 400, -img.height / 2 * scale + 300, img.width * scale, img.height * scale);


    ctx.fillStyle = 'rgb(calc(117 * 0.5), calc(109 * 0.5), calc(84 * 0.5), 0.5)'//'rgb(46, 40, 54, 0.7)';
    ctx.fillRect(0, 0, 800, 600);


    ctx.filter = 'none';

    ctx.fillStyle = 'rgb(254, 248, 247)';

    ctx.textAlign = 'center'
    ctx.textBaseline = 'middle';
    ctx.font = 'bold 150px Poppins';
    ctx.fillText('Codec', 400, 310);
    ctx.font = 'italic bold 23px Poppins';//ctx.font = 'italic 25px Poppins';//
    ctx.fillText('Projects that inspire', 397, 401);//ctx.fillText('Projects that inspire', 400, 415);//
};

/*
ctx.fillStyle = '#FEF8F7';
ctx.fillRect(0, 0, 600, 300);


const img = new Image();
img.src = '/projects/domain-warping/random-v-noise.png';

img.onload = () => {
    ctx.drawImage(img, 0, 0, 600, 250);

    ctx.fillStyle = 'rgb(85, 37, 42)';
    ctx.textAlign = 'center'
    // ctx.textBaseline = 'middle';
    ctx.font = 'bold 26px Poppins';
    ctx.fillText('Random', 150, 237.5);
    ctx.fillText('Noise', 450, 237.5);
};*/


// const lerp = (a, b, t) => a + (b - a) * t;
// const imgData = new ImageData(600, 250);
// for (let y = 0; y <= 250; y ++) {
//     for (let x = 0; x <= 600; x ++) {
//         const index = (y * 600 + x) * 4,
//             val = noise(x / 100, y / 100) * 0.5 + 0.5;
//         imgData.data[index    ] = lerp(85, 254, val);
//         imgData.data[index + 1] = lerp(37, 248, val);
//         imgData.data[index + 2] = lerp(42, 247, val);
//         imgData.data[index + 3] = 255;
//     }
// }
// ctx.putImageData(imgData, 0, 0);


// ctx.lineWidth = 3;
// ctx.strokeStyle = 'rgb(85, 37, 42)';

// ctx.beginPath();
// ctx.moveTo(300, 0);
// ctx.lineTo(300, 250);
// ctx.stroke();
// ctx.closePath();

// ctx.lineWidth = 2;
// ctx.beginPath();
// ctx.moveTo(0, (Math.random() * 2 - 1) * 100 + 125);
// for (let i = 10; i <= 300; i += 10) {
//     ctx.lineTo(i, (Math.random() * 2 - 1) * 100 + 125);
// }
// ctx.stroke();
// ctx.closePath();

// ctx.beginPath();
// ctx.moveTo(300, noise(0, 0.5) * 100 + 125);
// for (let i = 5; i <= 300; i ++) {
//     ctx.lineTo(i + 300, noise(i / 50, 0.5) * 100 + 125);
// }
// ctx.stroke();
// ctx.closePath();



const lctx = logo.getContext('2d');
logo.width = 16;
logo.height = 16;

lctx.clearRect(0, 0, 40, 40);


lctx.fillStyle = 'rgb(242, 233, 228)';
lctx.beginPath();
lctx.roundRect(0, 0, 16, 16, 8 * 16 / 33);
lctx.fill();
lctx.closePath();

// lctx.translate(0, 0);

lctx.fillStyle = lctx.strokeStyle = 'rgb(85, 37, 42)';
lctx.beginPath();
lctx.rect(-0.0, 0, 1.4, 16);
lctx.fill();
lctx.stroke();
lctx.closePath();

lctx.scale(16/33, 16/33);

window.setTimeout(() => {

    lctx.textAlign = 'center'
    lctx.textBaseline = 'middle';
    lctx.font = 'bold 26px Poppins';
    lctx.fillText('C', 8 * 33 / 16, 10 * 33 / 16);

    // const imgData = lctx.getImageData(0, 0, 16, 16);//184, 139, 0.3
    // for (let i = imgData.data.length; i -= 4;) {
    //     imgData.data[i    ] = 239 / 255 * imgData.data[i    ];
    //     imgData.data[i + 1] = 184 / 255 * imgData.data[i + 1];
    //     imgData.data[i + 2] = 139 / 255 * imgData.data[i + 2];
    //     imgData.data[i + 3] = 0.7 * 255;
    // }

    // lctx.putImageData(imgData, 0, 0);
}, 10);


        </script>

        <!-- Deals with loading images and editing -->
        <script type = 'text'>
            async function loadImage(img, url) {
                return new Promise(resolve => {
                    img.onload = () => resolve(img);
                    img.src = url;
                });
            }
            
            const img = document.getElementById('test-img');
            const fileReader = new FileReader();
            file.addEventListener('input', async e => {
                fileReader.addEventListener('load', async e => {
                    await loadImage(img, e.target.result);
                    render();
                });
                fileReader.readAsDataURL(file.files[0]);
            });
            
            const canvas = document.getElementById('test-canvas');
            const ctx = canvas.getContext('2d');
            function render() {
                ctx.drawImage(img, 0, 0, 600, 600);
            
                const imgData = ctx.getImageData(0, 0, 600, 600);
                for (let i = 0; i < imgData.data.length; i += 4) {
                    const alpha = 255 - imgData.data[i];
                    imgData.data[i    ] = 254;//117, 109, 84
                    imgData.data[i + 1] = 248;
                    imgData.data[i + 2] = 247;
                    imgData.data[i + 3] = alpha;
                }
                ctx.putImageData(imgData, 0, 0);
                createImageBitmap(canvas).then(bitmap => {
                    localStorage.setItem('penrose2', canvas.toDataURL());
                    console.log(bitmap);
                    console.log(localStorage.getItem('penrose2'));
                });
            }
            // console.log(localStorage.getItem('penrose2'))
                    </script>
    </body>
</html>

<!-- 
<h2>What is the Mandelbrot Set?</h2>
<p>
    <img class = 'img' src = '/projects/mandelbrot/thumbnail.png'>
    The Mandelbrot Set is a fractal, meaning that it has an infinite amount of detail.
    The more you zoom in, it will never smooth out. It's likely the most well known
    fractal in the world due to its iconic shape and how it's relatively simple to make.
    Additionally, it's related to many other fractals ideas in math, like Julia Sets,
    Newton's Fractal, and the bifurcation diagram. In fact, it contains copies of itself
    and other fractals!
</p>

<br>
<h2>How is the Mandelbrot Set Made?</h2>
<p>
    It makes use of a funky property of complex numbers: iteratively inputting a complex
    number <m-el>\(z\)</m-el> through a rational function creates fractal results. Since
    that's a lot to take in, we'll go over what that means. To start out, what is a
    rational function? A rational function is simply any function that equals one polynomial
    divided by another. For example, these are all rational functions:
</p>
<m-el>\[f\left(z\right)=\frac{z^{2}-3z+4}{2z^{3}-4}\]</m-el>
<m-el>\[f\left(z\right)=\frac{7z}{z^{5}-11z+1}\]</m-el>
<m-el>\[f\left(z\right)=\frac{-3z}{1}\]</m-el>
<p>
    For the Mandelbrot Set, we'll use a really simple one: <m-el>\(f\left(z\right)=z^{2}+c\)</m-el>.
    <m-el>\(z\)</m-el> always starts out as 0 (we'll get to what that means later) and <m-el>\(c\)</m-el> represents a "seed". This seed
    represents a pixel on the screen you're doing the calculation for. So, the real part of the number is the x coordinate and the y
    coordinate is the imaginary part. The fractal is actually very small, so you generally have to
    zoom in a lot.
</p>
<p>
    Secondly, "iteratively", in this case, means repeatedly composing the function into itself
    multiple times. So, after one iteration, <m-el>\(z=f\left(z\right)\)</m-el>, after two iterations
    <m-el>\(z=f\left(f\left(z\right)\right)\)</m-el>, after three <m-el>\(z=f\left(f\left(f\left(z\right)\right)\right)\)</m-el>,
    and so on. Ideally, we would use an infinite amount of iterations to get a perfectly accurate Mandelbrot,
    but that's unfortunately impossible, so we settle for a finite amount (the thumbnail image for this
    project is actually only 25 iterations). As was said before, the starting value of <m-el>\(z\)</m-el>
    will be zero, but after the first iteration, you input into the second iteration the output of the
    first iteration. This is probably pretty hard to understand just based on the words, so let's
    go through an example using pseudo code for a pixel, first spreading the process out and then
    rewriting it how you probably would in a program.
</p>
<div class='code'>
    <div class='code-pinline'></div>
    <pre>
z = 0 // z always starts out at 0

// The seed. Represents the coordinates of the pixel on the screen (scaled by some amount)
c = 0.4+0.1i

// The first iteration
z = z * z + c // z = 0.55+0.18i

// The second iteration
z = z * z + c // z = 0.6701+0.298i

// Etc.
z = z * z + c // z ≈ 0.7602+0.4994i
z = z * z + c // z ≈ 0.7286+0.8593i
z = z * z + c // z ≈ 0.1924+1.3521i
</pre>
</div>
<p>
    After 5 iterations, z equals about 0.1924+1.3521i. You'd find that writing that same bit of
    code over and over again a bit cumbersome, especially if you want to do many thousands of iterations
    so this is how you'll generally find it implemented:
</p>
<div class='code'>
    <div class='code-pinline'></div>
    <pre>
// Same setup
z = 0
c = 0.4+0.1i

// How many iterations will be run?
iter = 5 // In this case, five

// This is equivalent to adding iter number of f() around the expression in the composition example
repeat iter times:
    z = z * z + c

// After five iterations, z ≈ 0.1924+1.3521i, just like how it did in the spread out example
</pre>
</div>
<p>
    So far, we've only talked about the iteration process and have vaguely mentioned
    how it creates a fractal pattern, but how do we visualize it? There's actually many ways to visualize
    it, but we'll go with the standard way for this article. The standard way is to draw each pixel a certain color
    if the absolute value of <m-el>\(z\)</m-el> stays less than 2 (<m-el>\(z\)</m-el> stays <i>bounded</i>) after however many iterations you run,
    and, if <m-el>\(z\)</m-el> becomes greater than 2 (<m-el>\(z\)</m-el> <i>escapes</i>), draw a gradient based on what iteration <m-el>\(z\)</m-el>
    escapes. We do this process for every pixel on the screen with the only difference between any two pixels being the value
    of <m-el>\(c\)</m-el>. If you carry out this process for every pixel on your screen, you'll get the
    Mandelbrot set!
</p>
<br>
<h2>Demo: <a href='/projects/mandelbrot/mandelbrot.html' target='_blank'>Here</a></h2>
<br>
<h2>Further Reading</h2>
<ul>
    <li>
        <a href='https://en.wikipedia.org/wiki/Mandelbrot_set' target='_blank'>Mandelbrot Set</a> - Wikipedia.
        Goes a lot more into the math and into the special properties of it. Very thorough.
    </li>
    <li>
        <a href='https://www.youtube.com/watch?v=b005iHf8Z3g' target='_blank'>Mandelbrot Zoom Sequence</a> - Mathigon.
        Shows the infinite complexity of the Mandelbrot and its self similarity.
    </li>
    <li>
        <a href='https://www.youtube.com/watch?v=FFftmWSzgmk' target='_blank'>What's so special about the Mandelbrot Set?</a> - Numberphile.
        Gives a very nice, gradual introduction into the Mandelbrot Set as well as Julia Sets. It focuses a
        lot on the properties of iteration.
    </li>
</ul>

    <h2>What is Domain Warping?</h2>
                    <p>
                        <img class = 'img' src = './projects/domain-warping/thumbnail.png' style='width: 230px;'>
                        Using the tried and true method of "if you don't understand a
                        technical term, say it backwards, add grammar, and
                        maybe another word", we can deduce that domain warping is where
                        you warp the domain of a function (if you don't believe the
                        rule I proposed, take GPU; it stands for graphics processing unit.
                        What does it do? Well, it's a unit on a computer which
                        processes graphics). Essentially, how it works is that you have
                        some sort of function, like <m-el>\(f(x)\)</m-el>, and another
                        function <m-el>\(b(x)\)</m-el> which stays relatively close to
                        zero, you can compose, add them, multiply them, etc. them
                        to affect the output of. If you repeat this a couple of times
                        and add or multiply some values, then you can get
                        interesting effects like the image to the right. However, you
                        might be wondering why this is notable (apart from just looking
                        cool, of course). Domain warping can be used to create natural
                        and complex textures which resemble gasses and liquids. They
                        can be used in video games to look like gas giant planets.
                        In addition to that, domain warping is also used to take an
                        equation for a shape, like a circle or torus (donut), and
                        transform it in some way. These transformations can be almost
                        anything; you can make a shape wiggly or event twisted, if you're
                        working in 3D.
                    </p>
                    <br>
                    <h2>How are Textures Created?</h2>
                    <p>
                        <m-el>\(f\)</m-el> and <m-el>\(b\)</m-el> can be almost any
                        function, but generally continuous functions look the best.
                        As mentioned before, you also want <m-el>\(b\)</m-el> to
                        stay close to zero. For this article, we'll use something
                        called noise for both <m-el>\(f\)</m-el> and <m-el>\(b\)</m-el>. For those who don't know, noise is essentially
                        a way of creating random numbers that don't have jagged changes
                        and change smoothly. You can think of it as taking random numbers,
                        connecting them with lines, and then smoothing out where those line connect.
                        On the left are purly random numbers connected and values generated
                        by noise are on the right:
                    </p>
                    <div class='img-container'>
                        <img class='big-img' src='./projects/domain-warping/random-v-noise.png' style='max-width: 500px; width: 60%;' alt='A comparison of random numbers and numbers generated by noise'>
                        <span class='caption'>Random numbers are jagged and noise is smooth</span>
                    </div>
                    <p>
                        The example above is a 1D example. because there's only one input, <m-el>\(x\)</m-el>. To make images like
                        the one that are here, we want 2D noise, which has two input, <m-el>\(y\)</m-el>, and <m-el>\(y\)</m-el>.
                        Both dimensions of noise only have one output, so the dimension of the noise is determined
                        by how many inputs it has. This is what 2D noise looks like:
                    </p>
                    <div class='img-container'>
                        <img class='big-img' src='./projects/domain-warping/2D-noise.png' style='max-width: 500px; width: 60%;' alt='2D noise'>
                    </div>
                    <p>
                        Restating what was said before, simply combine the noise functions with
                        offsets and scaling until you achieve an image that you like. Additionally,
                        if you want to add some sort of animation, a good idea is to add or multiply
                        values by the time as part of your offsets and scaling. The reason why this
                        explanation is so vague is because you can do almost anything that you want
                        to the functions, and it will look at least somewhat interesting.
                    </p>
                    <br>
                    <div style='display: flex; flex-direction: column; float: right;'>
                        <img class = 'img' src = './projects/domain-warping/beauteous-circle.png' alt='A truly pulchritudinous circle'>
                        <img class = 'img' src = './projects/domain-warping/warped-beauteous-circle.png' alt='A warped circle, emanating pulchritude'>
                    </div>
                    <h2>How are Transformations Created?</h2>
                    <p>
                        Let's say you have a shape which you've defined with some sort of math, like the
                        beauteous circle on the right (top). It's defined by <m-el>\(x^{2}+y^{2}=r^{2}\)</m-el>, with <m-el>\(r\)</m-el> being the radius.
                        Very similarly to how the texture method works, you can simply warp the values of
                        <m-el>\(x\)</m-el> and <m-el>\(y\)</m-el> slightly to change the shape of it.
                        Again, this is vague because the warping can be many things. Simply adding a
                        sine wave to the x coordinate creates the image on the right (bottom).
                    </p>
                    <br>
                    <h2>Demos: <a href='./projects/domain-warping/textures.html' target='_blank'>Textures</a> and <a href='./projects/domain-warping/transformations.html' target='_blank'>Transformations</a></h2>
                    <br>
                    <h2>Further Reading</h2>
                    <ul>
                        <li>
                            <a href='https://iquilezles.org/articles/warp/' target='_blank'>Domain Warping</a> - Inigo Quilez.
                            Goes further in-depth about how to code the texture version, especially in GLSL and WebGL.
                        </li>
                    </ul>
    <h2>What is a Lorenz Attractor?</h2>
                    <img class = 'img' src = './projects/lorenz-attractor/thumbnail.png' style='rotate:  -90deg;'>
                    <p>
                        Edward Lorenz at one point was trying to model a part of how air moves in the
                        atmosphere when heated near the bottom and cooled at the top (this is called
                        atmospheric convection, but that's beside the point). He ran the simulation
                        on a computer and had a printer print out the current state of the simulation
                        as time went on. At one point, he decided that he wanted to run a simulation
                        of a certain initial state again, but he decided to restart the run halfway through
                        with one of the sets of values of the previous simulation. What he found was
                        that the results were entirely different! How could this be? It turned out that
                        the printer printed fewer decimal places than the computer used when simulating,
                        so, when Lorenz inputted the printer results back into the simulation, the
                        conditions he inputted were ever so slightly different from the conditions
                        that the computer actually stored. Even though the difference in conditions
                        was <i>tiny</i>, the effect that it had was extremely large. This idea that
                        small effects can have enormous consequences is called the Butterfly Effect.
                        Coincidentally, as you can see on the right, Lorenz Attractors look similar
                        to the wings of a butterfly.
                    </p>
                    <br>
                    <h2>How are They Created?</h2>
                    <p>
                        Lorenz's simulation was originally made up of 12 equations with 12 variables,
                        but he managed to simplify them down to just 3 equations with 3 variables.
                        Since there are only 3 variables, we can plot them in 3D space! Note that
                        there are also constants, but those don't change which means we don't have
                        to include them when plotting. These are the equations:
                    </p>
                    <m-el>\[\frac{dx}{dt}=\sigma\left(y-x\right)\]</m-el>
                    <m-el>\[\frac{dy}{dt}=x\left(\rho-z\right)-y\]</m-el>
                    <m-el>\[\frac{dz}{dt}=xy-\beta z\]</m-el>
                    <p>
                        These look fairly complex, especially if you aren't familiar with the notation,
                        but they're actually really simple. Normal equations, like <m-el>\(y=2x\)</m-el>,
                        for example, mean things like "when <m-el>\(x\)</m-el> equals <m-el>\(2\)</m-el>, <m-el>\(y\)</m-el>
                        equals <m-el>\(4\)</m-el>", but these are a bit different. In this case, these
                        equations say to add, rather than to set. So, each frame of the simulation
                        <m-el>\(\sigma\left(y-x\right)\)</m-el> is added to <m-el>\(x\)</m-el>. Going with
                        the same idea, <m-el>\(x\left(\rho-z\right)-y\)</m-el> is added to <m-el>\(y\)</m-el>, and you can probably
                        guess what gets added to <m-el>\(z\)</m-el>. For those who are curious, these types
                        of equations which are based on change are called differential equations, and are
                        part of calculus (so, if you understood that explanation, then you understand a bit
                        of calculus!). You might find that, when making the simulation, you need to scale
                        down what is added to each variable each frame; otherwise, the system of equations
                        could blow up and the variables will go off to infinity.
                    </p>
                    <p>
                        Right now, we haven't set the values of <m-el>\(\sigma\)</m-el>, <m-el>\(\rho\)</m-el>,
                        and <m-el>\(\beta\)</m-el>. The conventional values for them are 10, 28, and 8/3,
                        respectively. These will create the two lobes of the attractor, but other close
                        values will work as well. A lot of combinations will spiral into the center, while
                        others will spread out.
                    </p>
                    <p>
                        After the equations are updated each frame, graph their new positions in 3D
                        space. Something that's interesting to do is to graph multiple points which start off
                        very close together but not exactly in the same position and let the simulation run.
                        After a bit, the points will start to diverge and go on their own paths and won't
                        ever perfectly meet up with their companions, which is a very common demonstration
                        of the butterfly effect happening in real time.
                        How to render objects in 3D won't be covered here because the methods to do so
                        vary a lot depending on which language you're using. However, generally, it isn't to
                        hard to do as there are many libraries for a vast array of languages which make
                        drawing things in 3D much easier.
                    </p>
                    <br>
                    <h2 id = 'further-reading'>Further Reading</h2>
                    <ul id = 'further-reading-list'>
                        <li><a href = 'https://en.wikipedia.org/wiki/Lorenz_system'>Wikipedia: Lorenz system</a></li>
                    </ul> -->
<!-- <h2>What are Raytracers?</h2>
                    <div>
                        <img class = 'img' src = './projects/raytracing/thumbnail.png' style='margin-top: 4px;'>
                        <p>
                            Raytracers are a method of rendering 3D scenes. They're many
                            different types of 3D rendering and each one has it's own
                            advantages and disadvantages. The primary advantage of raytracers
                            is that they are highly realistic and are often used to create
                            photorealistic images. They achieve this photorealism by
                            simulating the paths of thousands of individual light rays. This
                            gives it its name since it's tracing where rays go. However,
                            this accuracy comes at a computational cost; it takes a long
                            time for images to be rendered with enough resolution to look
                            good. Despite that, recent advancements in AI have allowed
                            raytracing to work in real time while still maintaining the
                            same quality. We won't cover how the AI system works, but we
                            will go over how the base concepts of raytracing.
                        </p>
                    </div>
                    <br>
                    <h2>How Do They Work?</h2>
                    <p>
                        We do everything in reverse in the name of <i><strong>speed</strong>.</i> The Sun
                        produces light,<sup>[<i>citation needed</i>]</sup> but the vast majority of that light begins
                        its long lasting pilgrimage into the lonely depths of space, never to be seen by human eyes.
                        In other words, we don't care about it. If we were to simuluate all of that
                        light, we'd be wasting a lot of computational power. Instead, what we do in the 3D
                        rendering community is shoot light out of the camera and see what it hits (that's
                        right, we've got <i>lazer eyes</i>). The light rays that we cast out of the camera
                        will only contribute to the final image if they hit a light source, but they're much
                        more likely to hit a light source than light coming from a light source to hit the camera.
                        Now that we've established the back-to-front nature of raytracing, the question is,
                        how do we know if the rays hit something? We can use certain mathematical functions
                        to work it out for us. The simplest of these is the sphere-ray intersection function.
                        Surprisingly, it finds the intersection of a sphere and a ray, if one exists. Given
                        that it isn't too complex, let's derive it.
                    </p>
                    <p>
                        To start out, the equation for a sphere centered at the origin is <m-el>\(x^{2}+y^{2}+z^{2}=r^{2}\)</m-el>,
                        where <m-el>\(x\)</m-el>, <m-el>\(y\)</m-el>, and <m-el>\(z\)</m-el> are coordinates
                        and <m-el>\(r\)</m-el> is the radius. However, since we'll be working in vectors,
                        we can simply write this as <m-el>\(S\cdot S=r^{2}\)</m-el>. The equation for a ray
                        is <m-el>\(A+tB\)</m-el>. <m-el>\(A\)</m-el> is a vector representing the start of
                        the ray, <m-el>\(B\)</m-el> is a vector pointing in the direction of the ray, and 
                        t is a scalar which represents how far along the ray a point is. To begin our derivation,
                        it helps to define out goal a bit more. We want to find the intersection of a sphere
                        and a ray, but what that really means, is that we want to find a point that is both
                        on the sphere and on the ray. What we can do now is plug the equation for our
                        ray into <m-el>\(S\)</m-el> in the equation for a sphere as our starting equation. When the equation is
                        true, the point is both on the ray and on the sphere, which is what we want! This
                        is our current equation:
                    </p>
                    <m-el>\[\left(A+tB\right)\cdot\left(A+tB\right)=r^{2}\]</m-el>
                    <p>
                        When doing the
                        calculations, the values of the sphere, the starting point of the ray, and the
                        direction will all be defined by us, but we will want to find out how far along
                        the ray the point that intersects the sphere is. So, we want to solve for <m-el>\(t\)</m-el>.
                        Currently, <m-el>\(t\)</m-el> is encased in those pesky parentheses, so the next
                        step is to&nbsp;&nbsp;e x p a n d&nbsp;&nbsp;using the laws of vector algebra:
                    </p>
                    <m-el>\[t^{2}B\cdot B+2tA\cdot B+A\cdot A=r^{2}\]</m-el>
                    <p>
                        Now, something that you might notice which is pretty interesting is that we have a
                        quadratic equation in terms of <m-el>\(t\)</m-el>, so we can use the quadratic
                        formula to solve for <m-el>\(t\)</m-el> after a bit of rearranging:
                    </p>
                    <m-el>\[t^{2}B\cdot B+2tA\cdot B+A\cdot A-r^{2}=0\]</m-el>
                    <m-el>\[t=\frac{-2A\cdot B\pm\sqrt{\left(2A\cdot B\right)^{2}-4\left(B\cdot B\right)\left(A\cdot A-r^{2}\right)}}{2\left(B\cdot B\right)}\]</m-el>
                    <p>
                        We now know what <m-el>\(t\)</m-el> is! Now, that isn't a very friendly looking equation, but computers don't care, and
                        many of the terms are repeated, allowing you to store them as variables which
                        simplifies the equation a lot. An observant reader may have noticed that our
                        derivation only works with spheres centered at the origin, but we want the freedom
                        to choose where are spheres go. This presents an issue, which can be solved in two
                        main ways: rederiving with other positions in mind or shifting our reference frame.
                        In the name of consistency, we're going to shift our reference frame (most other
                        collision functions, like those of triangles, which are useful as you get more
                        advanced, require shifting reference frames, so it's good to get an understanding
                        of how it works sooner rather than later). How it works is that, before we use
                        our equation, we'll shift the sphere and the ray by some amount so that the sphere
                        is actually on the origin. Once we have the point on the sphere relative to the
                        origin, we can shift the scene and the intersection point back to where they
                        originally were. This can be done by subtracing the sphere's coordinates and then
                        adding the sphere's coordinate after the intersection point is found.
                    </p>
                    <p>
                        A small but important optimization is that we can use the determinant (the expression under the 
                        square root) to figure out a few more things about the intersection point. We won't
                        always have a single intersection; sometimes, the ray will completely miss the sphere
                        and other times, the ray will intersect the sphere twice (once on the way in and once
                        on the way out). The number of intersections is determined by the determinant. If it
                        is less than 0, then there won't be any intersections. If it is precisely equal to
                        0, then there will be one intersection. If it is greater than 0, then there will be
                        two intersections. This is helpful because we can stop the function before we get
                        to the square root which is very computationally expensive in most cases. You might
                        wonder what to do if there are two intersection points. In that case, you choose
                        the closest one which is the value of <m-el>\(t\)</m-el> when subtracting instead
                        of adding with the plus or minus part of the quadratic formula.
                    </p>
                    <div style='background-color: red;'>Maybe image here?</div>
                    <p>
                        The next step is figuring out how to cast the rays from the camera. Each pixel on the 
                        screen should have its own ray, so we need to figure out the starting point (<m-el>\(A\)</m-el>) and the direction (<m-el>\(B\)</m-el>)
                        of the ray based on its corresponding pixel's position. The starting point is easy as
                        it's just where the camera is positioned. We don't need to do any adjusting based on
                        the pixel's position. For the direction, rotate the rays slightly depending on where
                        the pixel is on the screen. For example, pixels on the left edge should be rotated
                        the most to the left, pixels in the center shouldn't be rotated horizontally at all and
                        pixels on the right should be rotated the most to the right. The same goes for the
                        vertical rotation of the rays, but it's top to bottom rather than left to right.
                        If you'd like a finer control, you can look into <a href='https://en.wikipedia.org/wiki/Field_of_view_in_video_games'>field of view (FOV)</a>, but that is
                        left as an exercise for the reader.
                    </p>
                    <p>
                        Now that we have the context out of the way, we can start to actually make a raytracer.
                        If you have a single sphere in the center, place the camera further back and draw one color
                        if a ray hits it and another color if a ray doesn't, you should get an image similar to this:
                    </p>
                    <div class='img-container'>
                        <img class='big-img' src='./projects/raytracing/basic.png'  style='max-width: 180px; width: 40%;'>
                    </div> -->
<!-- <h2>What are Penrose Tilings?</h2>
                    <p>
                        Let's say you have an infinite amount of tiles of a certain
                        shape, like a square. You can slide them together in a grid on a plane (an infinte flat surface)
                        and that grid will go on without stopping. The same goes for
                        triangles and hexagons. These grids are repeating which means
                        that if you have two copies of the grid, one on top of the
                        other, you can slide one around and it will line up perfectly
                        with the other. This is called a <i>periodic</i> tiling.
                        Other shapes don't have this special infinite
                        tiling property, like pentagons. However, if you allow more
                        shapes, than just the pentagon, you can tile the grid. A
                        question you might ask is, is it possible to create a finite
                        number of tiles that tile the plane, but <i>don't</i> tile it
                        periodically? In other words, is it possible to create an
                        infinite tiling that never repeats? The answer is actually yes!
                        The first set of tiles that people found had over 1,000 different
                        tiles in it and were called Wang Tiles. Other researchers
                        started trying to reduce the number of types of tiles and
                        slowly worked it down to a few hundred, and then down to six.
                        Now the protagonist of this story enters! Robert Penrose managed
                        to reduce the number of types of tiles to just two shapes: a
                        thick and a thin rhombus (affectionately called by mathematicians
                        "rhombs"). With those two tiles, you can create a pattern that
                        never repeats and yet goes on forever. This type of pattern is
                        called a penrose tiling and are what we'll be exploring here.
                        They've also been used in Islamic tilings.
                    </p>
                    <p>
                        There are variants of penrose tilings that use more than just
                        two types of tiles, such as the one depicted below. They are
                        still aperiodic and often look better, but it is worth noting
                        that not all images that are on this webpage are "true" penrose
                        tiles.
                    </p>
                    <div class='img-container'>
                        <img class='big-img' alt='An example of a penrose tiling variant used extensively across this website' src='./projects/penrose-tilings/penrose-background.png' style='max-width: 500px; width: 60%;'>
                        <span class='caption'>Penrose tilings are used all across this website.</span>
                    </div>
                    <h2>How are They Created?</h2>
                    <p>
                        This article will be different from most of the others, because
                        it'll go much more in-depth. There are very few resources on the
                        internet which are detailed enough to figure out how to create
                        penrose tilings and most of them are academic papers. I'm
                        attempting to give a full, yet understandable explanation of
                        how to create them in a program, rather than in real life.
                    </p>
                    <p>
                        To start off, a key concept is that there is an alternate representation of a
                        tiling. For a regular penrose tiling (i.e. only two tiles), that
                        representation is something called a pentagrid. A pentagrid is
                        where you have a 5 sets of parallel lines which are offset from
                        each other by 72°, as seen in the picture below.
                    </p>
                    <div class='img-container'>
                        <img class='big-img' alt='A pentagrid' src='./projects/penrose-tilings/pentagrid-better-colors.png' style='max-width: 180px; width: 40%;'>
                    </div>
                    <p>
                        It contains the
                        exact same information as the actual tiling, but just in another
                        form (you can think of it like how 9 in base ten is the same as
                        1001 in binary). Each intersection represents a single tile in the completed Penrose tiling. The
                        number and angles of the lines that intersect encode properties of
                        the tile. The shape that the intersection represents has 2 times
                        the number of lines that intersect. The angles of the lines dictate
                        how the overall rotation of the shape as well as the angles of the
                        edges. The method of creating a pentagrids is
                        rather peculiar. Essentially, you need to use an equation for a
                        line that is rarely ever used. It draws the line tangent to a circle
                        with a radius <m-el>\(r\)</m-el> at the point
                        <m-el>\(\theta\)</m-el> radians around the circle.
                        The following is the formula for that equation of a line.
                    </p>
                    <m-el>\[x\sin\left(\theta+\frac{\pi}{2}\right)=y\cos\left(\theta+\frac{\pi}{2}\right)+r\]</m-el>
                    <p>
                        Using this formula, you can create 5 lines with <m-el>\(r = 1\)</m-el>,
                        each rotated by an integer multiple of 72° (in radians, they would
                        be rotated multiples of <m-el>\(\frac{2\pi}{5}\)</m-el>).
                        Then, repeat this for as many increasing integers of <m-el>\(r\)</m-el>
                        as you would like. In other words, <m-el>\(r=1,2,3,4...\)</m-el> etc.
                        The more times you repeat this, the larger the eventual tiling will be.
                        This equation has one small issue, though. Right now, if you follow this
                        process exactly, the resulting pentagrid will have 5 lines intersecting
                        at the center. If we want to create a "true" penrose tiling, this will
                        create a third type of tile, which we don't want. In order to fix that,
                        we can simply add an offset from 0 to 1 to the lefthand side of the
                        equation, like so (notice the <m-el>\(o\)</m-el>):
                    </p>
                    <m-el>\[x\sin\left(\theta+\frac{\pi}{2}\right)+o=y\cos\left(\theta+\frac{\pi}{2}\right)+r\]</m-el>
                    <p>
                        Now that we have a pentagrid, the next step is to translate the pentagrid
                        into a penrose tiling. If you remember, each intersection translates to a
                        tile and the properties of the lines translate to the properties of the
                        tile, like number of sides and rotation. The nice this is, we don't have to
                        worry that much about the specifics, because the pentagrid also carries the
                        information on exactly how the vertices should be placed. That information
                        is held within the blank areas around the lines, as each blank area actually
                        represents a vertex of a shape (if you think about it, this leads to why
                        the tiles are guaranteed to fit so nicely together. Since multiple intersections
                        are bordering the same blank space, they all will share the same vertex).
                        Zooming in on a single intersection, each of the colored regions translates to a vertex of
                        the intersection's shape:
                    </p>
                    <div class='img-container'>
                        <img class='big-img' alt='A pentagrid' src='./projects/penrose-tilings/pentagrid-region-diagram.png' style='max-width: 180px; width: 40%;'>
                    </div>
                    <p>
                        As you can see, four regions border the intersection in the center, meaning that the
                        resulting shape will have four vertices, and therefore, will be a quadrilateral.
                        Up until now, we've been fairly abstract about how the whole translation
                        process will work. The secret is a special formula developed by de Bruijn:
                    </p>
                    <m-el>\[V\left(\overrightarrow{x}\right)=\sum_{j=0}^{4}K_{j}\left(\overrightarrow{x}\right)\overrightarrow{v_{j}}\]</m-el>
                    <p>
                        Since there's a lot going on, let's break it down. The function <m-el>\(V\)</m-el>
                        takes in a position, <m-el>\(\overrightarrow{x}\)</m-el>, and
                        outputs a vertex of a shape in the eventual tiling. <m-el>\(V(\overrightarrow{x})\)</m-el>
                        will always output the same point for inputs inside of the same region of the pentagrid.
                        <m-el>\(\overrightarrow{x}\)</m-el> and <m-el>\(\overrightarrow{v}\)</m-el>
                        are represented as vectors. Sums are inclusive, meaning that, in this case,
                        <m-el>\(j\)</m-el> has 5 values: 0, 1, 2, 3, and 4. 
                        <m-el>\(\overrightarrow{v_{j}}\)</m-el> is a unit vector with
                        an angle of <m-el>\(\frac{2\pi j}{5}\)</m-el> radians.
                        <m-el>\(K_{j}\left(\overrightarrow{x}\right)\)</m-el> is defined as
                        the following:
                    </p>
                    <m-el>\[K_{j}\left(\overrightarrow{x}\right)=\operatorname{ceil}\left(\overrightarrow{x}\cdot \overrightarrow{v}+o\right)\]</m-el>
                    <p>
                        <m-el>\(\operatorname{ceil}\)</m-el> is a function which rounds up
                        whatever its input is and <m-el>\(o\)</m-el> is the offset for the pentagrid.
                        Now that we have the formula defined, we can talk about how to use it. At each
                        intersection, simply find a point in each neighboring reigon and run that point
                        through the formula. Take the new vertices outputted by the formula and set them
                        to be the vertices of a tile. Repeat this process for as many intersections as you
                        would like to create differently sized tilings. An issue still remains. There might
                        be tiles floating off in space, disconnected from the main bulk of tiles. To get rid
                        of them, you can only create tiles that are a less than a certain distance from the
                        center. Now, you can draw the tiles and bask in the glory of your newly formed
                        penrose tiling!
                    </p>
                    <p>
                        <strong>But wait! There's <i>more!</i></strong> What you have now is a "true"
                        penrose tiling, but we're interested in exploring the falsehoods of this reality.
                        So, how can the aforementioned variants of penrose tilings be created? It's actually
                        pretty simple. All penrose tilings and their variants are rotationally symmetric,
                        meaning that you can rotate it about its center and it'll line up with itself. To
                        create variants, you need to increate the number of symmetries it has. This can simply
                        be done by adding more lines to the pentagrid. Just make sure that the rotations of
                        the lines from each other are changed from <m-el>\(\frac{2\pi}{5}\)</m-el> to
                        <m-el>\(\frac{2\pi}{s}\)</m-el>, where <m-el>\(s\)</m-el> is the number of symmetries.
                        De Bruijn's formula still works when there are more symmetries, but you're code probably
                        doesn't, so remember to go through and change parts that are depended on symmetries, like
                        the number and direction of the unit vectors as well as the upper bound of the sum in
                        de Bruijn's formula. Another thing that might need adjusting is how you handle the
                        intersection of multiple lines. Make sure it's compatible with more than two lines
                        at an intersection (for the vocabulary nerds like me, this is called a "point of
                        concurrency"). An added benefit is that the offset can now be set to 0 without issue
                        which often looks cool.
                    </p>
                    <br>
                    <h2>Helpful Tips</h2>
                    <ul>
                        <li>
                            If your tiles' vertices seem to be in the right place, but in a wacky order,
                            try sorting the lines by their angle first.
                        </li>
                        <li>
                            If you want to be able to store and differentiate different types of tiles
                            for coloring and other effects, you can find their area. Each type of tile
                            should have its own area. Remember to round it to a couple decimal places,
                            so floating point errors won't get in the way.
                        </li>
                        <li>
                            The sizes of the regions in pentagrids get what mathematicians say is "arbitrarily
                            small". In other words, they get tiny. Really tiny. Make sure that if you find points
                            in regions next to intersections by taking a step in the direction of the region from
                            the intersection, make sure that step is small enough; otherwise, you can go too far
                            and enter another region, which you don't want.
                        </li>
                        <li>
                            Often, lag will be caused by duplicated lines or tiles, so checking for those and
                            removing them can help. 
                        </li>
                    </ul>
                    <br>
                    <h2>Further Reading</h2>
                    <ul>
                        <li>
                            <a href='https://www.youtube.com/watch?v=-eqdj63nEr4'>Why Penrose Tiles Never Repeat</a> - minutephysics.
                            It's gives an excellent overview of the tilings as well as some intuitions about why the tilings act
                            how they do. It isn't too rigorous, though.
                        </li>
                        <li>
                            <a href='https://www.youtube.com/watch?v=48sCx-wBs34'>The Infinite Pattern That Never Repeats</a> - Veritasium.
                            Provides an overview of how the tilings work and give a lot of interesting facts about them.
                        </li>
                        <li>
                            <a href='http://www.neverendingbooks.org/tag/penrose-tiling'>de Bruijn's pentagrids</a> - LIEVENLB
                            An article which goes over how the formulas for translating the pentagrid works as well
                            as other facts and relations between other mathematical ideas.
                        </li>
                        <li>
                            <a href='https://web.williams.edu/Mathematics/sjmiller/public_html/hudson/HRUMC-Mowry&Shukla_Pentagrids%20and%20Penrose.pdf'>Pentagrids and Penrose Tilings</a> - Stacy Mowry and Shriya Shukla
                            Details a different slightly way of using de Bruijn's formula.
                        </li>
                        <li>
                            <a href='https://www.math.brown.edu/reschwar/M272/pentagrid.pdf'>Algebraic theory of Penrose's non-periodic tilings of the plane</a> - N.G. de Bruijn
                            De Bruijn's paper! It's very thorough and is the basis of almost all of the current methods.
                            It's unfortunately not the most understandable to the average reader.
                        </li>
                    </ul> -->